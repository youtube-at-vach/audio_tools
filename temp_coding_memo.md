# コーディングメモ: オーディオツール開発の指針

このメモは、`audio_tools` プロジェクトの既存コードベースのレビューを通じて得られた知見をまとめたものです。今後の開発において、コードの品質、保守性、効率性を高めるための指針として活用してください。

---

## 1. 全体的な設計原則

### a. モジュール性と責務の分離
各測定プログラムが独立したディレクトリに配置され、それぞれが特定の測定機能に特化している点は非常に優れています。これにより、コードの理解が容易になり、機能追加や修正の際に他の部分への影響を最小限に抑えられます。

**良い実践例:**
- `audio_analyzer` と `audiocalc` のように、UI/I/Oとコア計算ロジックを明確に分離する。
- 各ツールが `main()` 関数を持ち、`argparse` で引数を処理する一貫した構造。

**今後の指針:**
- 新しい機能を追加する際は、既存のモジュールに組み込むのではなく、独立した新しいモジュールや関数として設計できないか検討する。
- 各関数やクラスが単一の明確な責務を持つようにする。

### b. 明確な命名と可読性
変数名、関数名、クラス名がその役割を明確に示しているため、コードの意図が伝わりやすいです。適切なコメントもコードの理解を助けます。

**今後の指針:**
- 略語の使用は最小限に抑え、意味が明確なフルネームを優先する（例: `samplerate` ではなく `sample_rate`）。
- 複雑なロジックや非自明な処理には、その「なぜ」を説明するコメントを追加する。

## 2. 技術的な実践

### a. オーディオ信号処理の堅牢性
`numpy` と `scipy.signal` の効果的な使用により、FFT、フィルタリング、窓関数適用、RMS計算などが正確かつ効率的に行われています。

**良い実践例:**
- ゼロ除算や `log(0)` を避けるための `1e-12` のような小さな値での閾値処理。
- 窓関数適用後のエネルギー補正（例: `dynamic_range_analyzer` での修正）。
- `dBFS` と線形振幅間の変換の一貫性。

**今後の指針:**
- 信号処理を行う際は、常に数値的な安定性（例: ゼロ除算、オーバーフロー/アンダーフロー）に注意を払う。
- 窓関数を使用する場合は、その特性（例: コヒーレントゲイン、エネルギーゲイン）を理解し、必要に応じて補正を行う。

### b. `sounddevice` の適切な利用
オーディオI/Oライブラリ `sounddevice` の機能が最大限に活用されています。

**良い実践例:**
- `sd.playrec` を用いた同時再生・録音。
- `input_mapping` や `output_mapping` を用いたチャンネルの明示的な指定（`snr_analyzer` での修正）。
- デバイスの列挙、選択、およびチャンネル数の検証。
- `PortAudioError` の適切なハンドリングと、ユーザーへの分かりやすいエラーメッセージ。

**今後の指針:**
- `sounddevice` のバージョンによるAPIの差異（特に `playrec` の `output_mapping` など）に注意し、必要に応じてバージョン依存のコードや警告を記述する。
- リアルタイムオーディオコールバック内では、処理負荷の高い操作（例: `print`、複雑な計算）を避ける。

### c. コマンドラインインターフェース (CLI) の設計
`argparse` と `rich` を組み合わせることで、非常に使いやすく、情報豊富なCLIが構築されています。

**良い実践例:**
- `argparse` の `choices`、`default`、`help` メッセージの活用。
- `rich.console`、`rich.table`、`rich.prompt` を用いた、視覚的に分かりやすく、インタラクティブなユーザー体験。
- `--list-devices` のような、ユーザーが環境を把握するためのユーティリティオプション。

**今後の指針:**
- 新しい引数を追加する際は、既存の命名規則やデフォルト値のパターンに従う。
- エラーメッセージは具体的かつ行動可能（例: 「このデバイスIDは無効です。0からXの範囲で選択してください」）にする。

### d. テストの重要性
多くのモジュールで `pytest` を用いたユニットテストが書かれており、コードの信頼性を高めています。特に、外部ライブラリ（`sounddevice`）のモック化は、テストの独立性と実行速度を確保する上で重要です。

**良い実践例:**
- `unittest.mock.patch` を用いた依存関係の分離。
- エッジケース（例: 空の入力、ゼロ値）をカバーするテストケース。

**今後の指針:**
- 新しい機能や修正を加える際は、必ず関連するユニットテストを作成または更新する。
- テストカバレッジを意識し、主要なロジックがテストされていることを確認する。

## 3. 今後の改善点と注意点

### a. パフォーマンスとリソース管理
- `audio_lissajous_analyzer` のようなリアルタイムプロットでは、オーディオバッファとプロット更新間の同期に注意を払う。現在の実装はシンプルで実用的ですが、より厳密なアプリケーションでは `threading.Lock` などの同期メカニズムが必要になる場合がある。
- `matplotlib` を使用する際は、非対話型環境での動作（`matplotlib.use('Agg')`）や、プロットオブジェクトの明示的なクローズ（`plt.close(fig)`）を忘れずに行い、メモリリークを防ぐ。

### b. ドキュメンテーションとコメント
- コード内のコメントは、その「なぜ」を説明することに重点を置く。
- 各ツールの `README.md` ファイルを常に最新の状態に保ち、使用方法、引数、出力形式などを明確に記述する。
- `GEMINI.md` や `temp_procedure_doc.md` のようなプロジェクトレベルのドキュメントも、新しい知見が得られるたびに更新する。

---

このメモが、今後の `audio_tools` プロジェクトの発展に貢献することを願っています。
