# 新規測定プログラム製作手順 (New Measurement Program Production Procedure)

このドキュメントは、本リポジトリに新しいオーディオ測定プログラムを追加する際の標準的な手順を概説するものです。

## 1. 企画・設計 (Planning and Design)

-   **将来のアイデア確認**: まず `misc/future_tool_ideas.md` を確認し、既存の将来的なツール構想やアイデアに合致するものがないか、または参考にできる点がないかを確認します。
-   **目的の明確化**: 新しい測定プログラムが解決する課題、測定する具体的なオーディオ特性（例: THD+N, 周波数特性, IMDなど）を定義します。
-   **既存ツールの確認**: リポジトリ内に類似の機能を持つツールがないか確認します。既存ツールを拡張できる場合は、新規作成よりも優先します。
    -   **未カバーの測定カテゴリ特定**: 基本的なオーディオ測定カテゴリ（例：高調波歪み、周波数特性、相互変調歪み、ノイズ、ステレオ特性、過渡応答など）をリストアップし、未カバーの領域を特定します。例えば `audio_crosstalk_analyzer` はステレオ特性の未カバー領域（信号漏れ）に焦点を当てています。
-   **必要な機能のリストアップ**: もし協力者がいればレビューを受け、フィードバックに基づいて修正を行います。
    -   入力信号の種類（例: サイン波、矩形波、ホワイトノイズ、外部ファイル）
    -   ユーザーが設定可能なパラメータ（例: 周波数、振幅、テスト時間、FFTサイズ）
    -   出力形式（例: コンソールへのテキスト表示、グラフ表示、CSVファイルへの保存）
    -   対応するオーディオ規格や測定方法（例: SMPTE, DIN, CCIF for IMD）
-   **使用ライブラリの選定**: `numpy`, `scipy`, `sounddevice`, `matplotlib`, `rich`など、プロジェクトで共通して使用されているライブラリを基本とします。
-   **依存関係の確認**: 新たなサードパーティライブラリが必要な場合は、そのライブラリがプロジェクトの他の部分と競合しないか、ライセンスは適切かを確認します。可能であれば、既存のライブラリで代替できないか検討します。

## 2. 開発環境の準備 (Development Environment Setup)

-   **Pythonバージョン**: **Python 3.9+** を使用します。これにより、モダンな型ヒント構文 (`tuple[int]` など) が利用できます。
-   **依存関係のインストール**: プロジェクトルートの `requirements.txt` を使って、共通の依存ライブラリをインストールします。
    ```bash
    pip install -r requirements.txt
    ```
    - ツール固有の依存関係がある場合は、そのツールのディレクトリにある `requirements.txt` を使って追加でインストールします。
    - **システムライブラリの確認**: `sounddevice` が依存するPortAudio (`libportaudio2` など) がシステムにインストールされていることを確認してください。これは実行時エラーの一般的な原因です。
-   **Gitリポジトリ**: `git clone` または `git pull` でリポジトリを最新の状態に更新します。

## 3. 実装 (Implementation)

-   **モジュール構成**: 
    -   プログラムの主たる機能は、リポジトリルート直下に作成する専用のディレクトリ（例: `new_tool_analyzer/`）に配置します。
    -   メインスクリプトは `new_tool_analyzer/new_tool_analyzer.py` のように命名します。
    -   ディレクトリ内には `__init__.py` を配置し、Pythonパッケージとして認識できるようにします。
-   **信号生成**: 
    -   必要なテスト信号を生成する関数を実装します。可能であれば既存の信号生成ツール（例: `audio_signal_generator`）の機能を活用します。
-   **オーディオ入出力 (Audio I/O)**:
    -   `sounddevice` ライブラリを使用します。
    -   **デバイス選択**: ユーザーがオーディオデバイスをIDまたは名前で選択できるようにします。`rich` を使ってデバイスリストを分かりやすく表示することを推奨します。
    -   **ストリーミング方式の選択**:
        -   **一括再生・録音**: `sd.playrec()` は、決まった長さの信号を再生し、同時に録音する場合に適しています。多くの測定ツールでこの方式が使われています。
        -   **リアルタイム処理**: `sd.InputStream` や `sd.Stream` のコールバック方式は、リアルタイムでのデータ可視化（例: `audio_lissajous_analyzer`）など、連続的なデータ処理が必要な場合に適しています。
    -   **チャンネルマッピングとAPIの変更点**: 
        -   `sounddevice` ライブラリのバージョン `0.5.2` 以降では、`sd.check_hostapi()` 関数は非推奨または削除されています。このチェックは通常、`sd.InputStream` や `sd.OutputStream` の初期化時に内部的に行われるため、明示的に呼び出す必要はありません。
        -   `sd.playrec()` や `sd.InputStream`/`sd.OutputStream` の `mapping` 引数（または `input_mapping`/`output_mapping`）も、バージョン `0.5.2` 以降では削除されています。
        -   **入力チャンネルの選択**: 録音されたデータ (`indata` または `recorded_audio`) から、NumPyのスライス (`recorded_audio[:, [ch1_idx, ch2_idx]]`) を使用して、必要なチャンネルを抽出します。`channels` 引数には、デバイスがサポートする最大入力チャンネル数を指定するか、または必要なチャンネル数（例: ステレオの場合は2）を指定します。
        -   **出力チャンネルの選択**: `sd.playrec()` における物理的な出力チャンネルのマッピングは、`mapping` 引数の削除により直接サポートされなくなりました。信号はデバイスのデフォルト出力チャンネルにルーティングされます。この制限を考慮した上で設計を行ってください。
    -   **チャンネルインデックスの事前検証**: ユーザーが指定したチャンネルインデックスが、`sd.query_devices()` で取得した `max_input_channels` や `max_output_channels` の範囲内にあることを必ず検証し、範囲外の場合は親切なエラーメッセージを表示します。
-   **解析処理と表示の分離**: 解析ロジック（Numpy/Scipyでの計算）と結果の表示ロジック（Rich/Matplotlibでの出力）を、可能な限り関数レベルで分離することを強く推奨します。解析関数は計算結果（数値、リスト、辞書など）を返し、それを別の関数が表示用に整形することで、コードの単体テストが容易になります。
-   **FFTを用いた解析では**、正確な振幅スペクトルを得るための正規化や、既知の周波数成分を正確に捉えるための周波数ビン選択/補間処理に注意を払います。
-   **フィルター選択に関する注意点 (Notes on Filter Selection)**:
    -   **IIRノッチフィルターの注意点**: `scipy.signal.iirnotch` のようなIIRフィルターは、特にQ値が高い設定の場合、ノッチ周波数から離れた周波数で予期せぬゲインを持つことがあります。これにより、広帯域のノイズフロア測定時に全体のエネルギーが増加し、不正確な結果（例: SN比やダイナミックレンジの悪化）を招く可能性があります。高精度なノイズ測定で特定のトーンを除去する際は、この挙動に注意が必要です。
    -   **FFTフィルタリングの推奨**: 上記の問題を回避するため、特定の周波数成分を除去する際には、FFTを用いて周波数領域に変換し、該当する周波数ビン（およびその周辺）をゼロ化した後、逆FFTで時間領域信号に戻す手法がより安全で副作用がありません。この方法は、他の周波数帯への影響を最小限に抑えることができます。
    -   **標準フィルター実装の複雑さ**: A特性フィルターのような業界標準フィルターを、極とゼロ点の定義から動的に設計する作業は、アナログ-デジタル変換時の周波数ワーピングやゲイン正規化の過程で、微妙な数値精度の問題が発生しやすく、非常にデリケートです。可能であれば、ターゲットとするサンプリング周波数に対して、既知の検証済みSOS（Second-Order Sections）係数を使用する方が、堅牢な実装につながります。
-   無音や非常に短い信号など、エッジケースを考慮し、エラーで終了する代わりに警告を出すなど、堅牢な処理を実装します。

## 4. テスト (Testing)

-   **既存テストの事前実行**: 新機能の開発に着手する前に、まず `python3 -m unittest discover` を実行し、現在のテストがすべて成功することを確認します。これにより、既存コードの予期せぬ不具合に早期に気づくことができます。
-   **単体テスト (Unit Tests)**:
    -   主要な関数（信号生成、解析処理など）に対して単体テストを作成します。
    -   Pythonの `unittest` フレームワークを使用し、テストスクリプトは `new_tool_analyzer/test_new_tool_analyzer.py` のように命名します。
    -   テストケースでは、既知の入力に対する期待される出力を検証します。`unittest.mock` を活用して、ハードウェアに依存する部分（例: `sounddevice` の呼び出し）をモック化します。
    -   **`rich` を使用した出力のテスト**: `rich` の `Table` や `Panel` などの出力をテストする場合、`unittest.mock.patch` を使って `rich.console.Console.print` をモック化します。アサーションでは、モックに渡された `Table` オブジェクトのプロパティ（例: `title`, `rows`, `columns`）を検証するか、オブジェクトを文字列化して特定の部分文字列が含まれているかを確認します。後者は、複雑なオブジェクトの内部構造に依存しないため、より堅牢なテストになる場合があります。
-   **テストの実行**:
    -   開発中および完了後には、リポジトリのルートディレクトリから **`python3 -m unittest discover`** を実行し、新規追加分を含むプロジェクト全体のテストが成功することを確認します。これにより、変更が他のツールに影響を与えていないことを保証します。
-   **テスト環境**:
    -   テストコードが依存するライブラリがテスト環境で利用可能であること、また、必要なシステムレベルの依存関係（例：PortAudio）が満たされていることを確認します。

## 5. ドキュメント作成 (Documentation)

#### 5.1. ツール固有の `README.md` 作成

各ツールディレクトリ（例: `new_tool_analyzer/`）には、必ず `README.md` を作成します。このファイルには、以下の情報を明確かつ簡潔に記載してください。

-   **ツールの概要**:
    -   このツールが何をするものなのか、一文で説明します。
    -   どのような目的（例: スピーカーの位相チェック、アンプの歪み測定）で使用されるのかを記述します。

-   **依存ライブラリ**:
    -   このツールが依存するPythonライブラリをリストアップします。
    -   プロジェクト共通の `requirements.txt` に含まれるライブラリと、このツール固有のライブラリを明記します。
    -   インストールコマンドの例を記載します。
        ```markdown
        # 共通ライブラリのインストール
        pip install -r ../requirements.txt

        # このツール固有のライブラリのインストール (もしあれば)
        pip install -r requirements.txt
        ```

-   **使用方法**:
    -   基本的なコマンドラインの実行例を記載します。
    -   `--help` で表示される主要なオプション（特に重要なもの）をリストアップし、それぞれの役割とデフォルト値を説明します。

-   **出力結果の例**:
    -   ツールの実行結果（コンソール出力や生成されるグラフ）のサンプルを記載し、ユーザーがどのような情報を得られるのかを示します。

-   **注意事項**:
    -   正しい測定に必要な前提条件（例: オーディオインターフェースのループバック設定、マイクの配置）や、測定結果に影響を与える可能性のある要因について記述します。

#### 5.2. プロジェクトルートの `README.md` 更新

新しいツールを追加したら、プロジェクトのトップレベルにある `README.md` のツールリストを更新します。以下のルールに厳密に従ってください。

1.  **リストへの追加**:
    -   既存のツールリストの中から、新ツールのカテゴリに最も近い場所を見つけて項目を追加します。リストの順序は、関連性の高いツールが近くに配置されるように意識してください。

2.  **表記ルール**:
    -   **言語**: 全てのツールの説明は日本語で記述します。
    -   **項目名**: 各ツールリストの項目は、ツールの日本語名で開始します。
    -   **リンク形式**: ツールのディレクトリ名はバッククォート（` `` `）で囲み、そのディレクトリ内の `README.md` ファイルへのリンクとします。
        -   例: `- リサージュアナライザー ([\`audio_lissajous_analyzer\`](./audio_lissajous_analyzer/README.md)): （ここに説明文）`
    -   **説明文**:
        -   ツールが「何をするのか」「どのような機能を持つのか」を明確に記述します。
        -   専門用語を避け、平易な言葉で説明することを心がけてください。
    -   **装飾**: ツール名や説明文に太字やイタリックなどの特別な文字装飾は使用しません。

## 6. プルリクエストとレビュー (Pull Request and Review)

-   変更内容をコミットし、GitHub上でプルリクエストを作成します。
-   （もし協力者がいれば）レビューを受け、フィードバックに基づいて修正を行います。
-   全てのチェックが通ったら、メインブランチにマージします。

## 7. その他 (Miscellaneous)

-   **ライセンス**: 本リポジトリの他のツールと同様に、Unlicense を適用し、著作権を放棄します。READMEにその旨を記載します。
-   **ファイルエンコーディング**: すべてのテキストファイル（.py, .md, .txt など）は UTF-8 で保存します。

## 8. 知見の記録と将来構想へのフィードバック (Logging Knowledge and Feedback to Future Concepts)

-   **新たな知見・アイデアの記録**: 作業完了後、開発プロセスを通じて得られた新たな知見、または将来的に有用と思われる新しい測定ツールのアイデアが生まれた場合は、`misc/future_tool_ideas.md` に追記して下さい。これは将来のツール開発のための貴重なリソースとなります。

---
この手順はあくまでガイドラインであり、開発するツールの特性や規模に応じて適宜調整してください。