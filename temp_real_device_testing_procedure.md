# 実機を用いたオーディオ測定ツールの検証手順

## 目的

本ドキュメントは、開発中のオーディオ測定ツール群が実機環境において正しく機能し、特に計算結果の正確性が確保されていることを検証するための手順を定めるものです。各ツールの出力が、既知の入力信号や信頼できる外部測定器のデータと一致することを確認します。

## 測定の前提条件：明確なループバック経路の確保

多くのテストは、オーディオインターフェースの出力を入力に直接接続する「ループバック」接続を前提としています。これにより、ケーブルやデバイス自身の電気的性能を正確に測定できます。

しかし、使用するデバイスによっては、内部のミキサー機能や複雑なルーティング設定により、物理的な接続だけでは意図した通りのループバック経路が確立されているか不明確な場合があります。

このような場合、測定を開始する前に `audio_loopback_finder.py` ツールを使用してください。このツールは、テスト信号を各出力チャンネルから順に送信し、すべての入力チャンネルを監視することで、実際に信号が通過しているアクティブなオーディオ経路を特定します。これにより、意図した通りのループバックが確立されているか、あるいは予期せぬ経路が存在しないかを事前に確認できます。明確なループバックが確認できてから、各ツールの検証に進んでください。

## dBFSの定義と使い分け

本ツール群では、音量レベルの表現にdBFS (decibels relative to full scale) を使用しますが、dBFSには主に「ピークdBFS」と「RMS dBFS」の2種類があり、それぞれ異なる目的で使われます。この違いが測定結果の解釈に影響を与えるため、以下にその指針を示します。

### 1. ピークdBFS (Peak dBFS)

*   **定義**: デジタル信号の瞬間的な最大振幅（ピーク値）を基準としたdB値です。0 dBFSがデジタルシステムの最大許容レベルであり、これを超えるとデジタルクリッピングが発生します。
*   **主な用途**: 信号の生成時や、デジタルクリッピングを防ぐための最大レベルの監視に用いられます。音量の「上限」を示す指標です。

### 2. RMS dBFS (Root Mean Square dBFS)

*   **定義**: 信号の平均的なパワー（実効値）を基準としたdB値です。人間の聴覚が感じる「音量」や「ラウドネス」に最も近い指標とされます。
*   **主な用途**: 信号の平均的なレベル、ノイズフロア、ゲイン、SNRなどのオーディオ分析に広く使用されます。音量の「平均的な大きさ」を示す指標です。

### 本プロジェクトにおける指針

*   **信号の生成や最大レベルの指定**: **ピークdBFS**を使用します。これは、デジタルクリッピングを防ぐ上で最も重要です。
*   **信号の分析、ゲイン、ノイズ、ラウドネスなど、平均的なパワーや聴感上の音量に関わる測定**: **RMS dBFS**を使用します。

各ツールの出力において、どのdBFSが使われているかを注意深く確認してください。

## 全体的なアプローチ

1.  **基準となるハードウェアの準備**: 信頼性の高いオーディオインターフェース、校正済みの測定用マイク、高品質なループバックケーブルなどを用意します。
2.  **基準信号の生成**: ツール自身 (`audio_signal_generator.py`) または外部のプロフェッショナルな信号発生器を用いて、正確な特性を持つテスト信号を生成します。
3.  **比較検証**:
    *   ツールの出力値を、理論的な期待値、または信頼できる既知のオーディオ分析ソフトウェア/ハードウェア（例: Audacity, REW (Room EQ Wizard), オシロスコープ、高精度電圧計など）の測定結果と比較します。
    *   視覚的な出力（プロットなど）がある場合は、その形状や特性が期待通りであることを目視で確認します。
4.  **段階的なテスト**: 各ツールを個別にテストした後、必要に応じて複数のツールを組み合わせてテストします。
5.  **詳細な記録**: 各テストの条件、測定結果、期待値との差異、およびその原因（判明した場合）を詳細に記録します。

## 各測定ツールの検証手順

### 1. `audio_analyzer.py` (THD, THD+N, SNR, Gain)

**目的**: 正弦波のTHD, THD+N, SNR, ゲインが正確に測定されることを確認する。

**準備**:
*   高品質なオーディオインターフェース
*   ループバックケーブル（インターフェースの出力と入力を接続）

**手順**:
1.  **純粋な正弦波の測定**:
    *   `audio_signal_generator.py` を使用して、様々な周波数（例: 100Hz, 1kHz, 10kHz）と振幅（例: -6dBFS, -20dBFS, -60dBFS）の純粋な正弦波を生成し、WAVファイルとして保存します。
    *   `audio_analyzer.py` をループバックモードで実行し、これらのWAVファイルを再生しながら測定します。
    *   **検証**:
        *   THD, THD+N が非常に低い値（例: 0.001%以下）であることを確認します。
        *   ゲインが0dBに近いことを確認します。
        *   SNRがオーディオインターフェースの仕様に近い値であることを確認します。
    **ゲインに関する補足**: `audio_analyzer.py` で表示される「FFT処理ゲイン(dB)」は、出力信号のピークdBFSと、入力信号の基本周波数成分のピーク振幅の差から、`audio_calibration_tool.py` で測定された物理ゲインを差し引いた値です。この値が0dBに近いほど、FFT解析と窓関数による影響が小さいことを示します。FFT解析と窓関数は信号のエネルギーを周波数ビンに分散させるため、通常、この「FFT処理ゲイン(dB)」は負の値（減衰）を示します。例えば、Blackman-Harris窓の場合、理論的な処理ゲインは約 -7.47 dB です。測定された値がこの理論値から大きくずれる場合、スカロップ損失（周波数がFFTビンに完全に一致しないことによる損失）や、その他の要因が考えられます。これは、ツールの計算が間違っているわけではなく、デジタル信号処理の避けられない特性を示しているものです。
2.  **既知の歪みを持つ信号の測定**:
    *   意図的に歪みを加えた信号（例: 矩形波やクリップした正弦波）を生成し、`audio_analyzer.py` で測定します。
    *   **検証**: THD, THD+N が期待される高調波成分を反映した値になることを確認します。
3.  **ノイズフロアの測定**:
    *   入力に何も接続しない（または終端抵抗を接続した）状態で、`audio_analyzer.py` をノイズ測定モードで実行します。
    *   **検証**: 測定されたノイズRMSがオーディオインターフェースのノイズフロア仕様に近いことを確認します。
4.  **ゲインの検証**:
    *   オーディオインターフェースの入力または出力に既知のゲイン/アッテネーションを持つプリアンプやアッテネーターを接続し、`audio_analyzer.py` でゲインが正しく測定されることを確認します。

### 2. `audio_calibration_tool.py`

**目的**: dBFSと実電圧（Vrms）間の変換が正確に行われることを確認する。

**準備**:
*   高品質なオーディオインターフェース
*   高精度なAC電圧計（マルチメーター）
*   ループバックケーブル

**手順**:
1.  **出力キャリブレーション**:
    *   `calibration_tool.py` を `calibrate` モードで実行します。
    *   オーディオインターフェースの出力にAC電圧計を接続し、ツールが生成するテストトーンのRMS電圧を測定します。
    *   測定値をツールに入力し、0dBFSに対する換算量（dBVrms）が正しく計算されることを確認します。
    *   **検証**: 計算された換算量が、インターフェースの仕様や他の信頼できる情報源と一致することを確認します。
2.  **ループバックテストと分析**:
    *   `calibration_tool.py` を `test` モードで実行し、ループバック接続でテストトーンを再生・録音します。
    *   `analyze` モードで録音されたWAVファイルを分析し、周波数スペクトルが期待通りであることを確認します。
    *   **検証**: ピーク周波数と振幅が、生成されたテストトーンの特性と一致することを確認します。
3.  **キャリブレーションの自動確認 (AI操作用)**:
    *   キャリブレーションが正しく行われているかをAIが自動で確認するために、`check` モードを使用します。
    *   このモードは、基準信号を再生し、入力レベルを測定してキャリブレーションの成否を判定し、結果を出力してすぐに終了します。
    *   **実行コマンド**: `python3 audio_calibration_tool/calibration_tool.py check`
    *   **検証**: コマンドの出力が `キャリブレーション成功` となっていることを確認します.

### 3. `audio_crosstalk_analyzer.py`

**目的**: チャンネル間のクロストークが正確に測定されることを確認する。

**準備**:
*   高品質なオーディオインターフェース
*   ループバックケーブル（インターフェースの出力と複数の入力チャンネルを接続できる構成）

**手順**:
1.  **単一周波数テスト**:
    *   `audio_crosstalk_analyzer.py` を実行し、特定の出力チャンネルからモノラル信号を再生します。
    *   参照入力チャンネル（信号が直接入るチャンネル）と、クロストークを測定したい他の入力チャンネルから同時に録音します。
    *   **検証**:
        *   参照チャンネルのレベルが期待通りであることを確認します。
        *   他のチャンネルのクロストークレベルが、オーディオインターフェースのチャンネルセパレーション仕様に近い値であることを確認します。
        *   非常に低いクロストーク値（例: -80dB以下）が正しく測定されることを確認します。
2.  **周波数スイープテスト**:
    *   `--sweep` オプションを使用して、広範囲の周波数でクロストークを測定します。
    *   結果をCSVに保存し、プロットを生成します。
    *   **検証**:
        *   生成されたプロットが、周波数に対するクロストークの一般的な傾向（通常、高周波で悪化する）を正しく示していることを確認します。
        *   CSVデータとプロットの数値が一致することを確認します。

### 4. `audio_freq_response_analyzer.py`

**目的**: オーディオシステムの周波数応答（振幅と位相）が正確に測定されることを確認する。

**準備**:
*   高品質なオーディオインターフェース
*   ループバックケーブル
*   （オプション）既知の周波数応答特性を持つフィルターやEQ

**手順**:
1.  **ループバックでの測定**:
    *   `audio_freq_response_analyzer.py` をループバック接続で実行し、広範囲の周波数スイープを行います。
    *   **検証**:
        *   振幅応答がほぼフラット（例: +/-0.1dB以内）であることを確認します。
        *   位相応答がほぼフラット（例: +/-5度以内）であることを確認します。
        *   プロットが期待通りに表示されることを確認します。
2.  **既知のフィルターを通した測定（オプション）**:
    *   オーディオインターフェースのループバック経路に、既知の特性を持つハードウェアフィルター（例: ローパスフィルター、ハイパスフィルター）を挿入します。
    *   `audio_freq_response_analyzer.py` で測定します。
    *   **検証**: 測定された周波数応答と位相応答が、フィルターの理論的な特性と一致することを確認します。

### 5. `audio_imd_analyzer.py` (SMPTE, CCIF)

**目的**: 相互変調歪み（IMD）がSMPTEおよびCCIF規格に従って正確に測定されることを確認する。

**準備**:
*   高品質なオーディオインターフェース
*   ループバックケーブル

**手順**:
1.  **SMPTE IMDの測定**:
    *   `audio_imd_analyzer.py` を `--standard smpte` オプションで実行します。
    *   **検証**:
        *   非常にクリーンなループバックの場合、IMD値が非常に低いこと（例: 0.005%以下）を確認します。
        *   意図的にクリップさせるなどして歪みを発生させ、IMD値が増加することを確認します。
        *   IMDプロダクトの詳細テーブルに表示される周波数とレベルが、理論的な期待値と一致することを確認します。
2.  **CCIF IMDの測定**:
    *   `audio_imd_analyzer.py` を `--standard ccif` オプションで実行します。
    *   **検証**:
        *   非常にクリーンなループバックの場合、IMD値が非常に低いこと（例: 0.005%以下）を確認します。
        *   d2, d3などのIMDプロダクトの周波数とレベルが、理論的な期待値と一致することを確認します。

### 6. `audio_lissajous_analyzer.py`

**目的**: ステレオ信号の位相関係がリサジュー図として正確に視覚化されることを確認する。

**準備**:
*   高品質なオーディオインターフェース
*   ループバックケーブル
*   （オプション）位相シフトを生成できるソフトウェアまたはハードウェア

**手順**:
1.  **既知の位相関係の信号の入力**:
    *   `audio_signal_generator.py` または他のソフトウェアで、以下の信号を生成し、オーディオインターフェースのステレオ入力に送ります。
        *   **モノラル信号**: 左右チャンネルが同一の信号。
        *   **90度位相差の信号**: 左右チャンネル間に90度の位相差がある信号。
        *   **180度位相差の信号**: 左右チャンネル間で位相が反転している信号。
    *   `audio_lissajous_analyzer.py` を実行し、リサジュー図をリアルタイムで表示します。
    *   **検証**:
        *   モノラル信号の場合、垂直な直線が表示されることを確認します。
        *   90度位相差の場合、円が表示されることを確認します。
        *   180度位相差の場合、負の傾きの直線が表示されることを確認します。
        *   その他の位相差の場合、楕円が表示され、その形状が期待される位相関係を反映していることを確認します。

### 7. `audio_phase_analyzer.py`

**目的**: ステレオ信号間の位相差が正確に計算されることを確認する。

**準備**:
*   高品質なオーディオインターフェース
*   ループバックケーブル
*   （オプション）位相シフトを生成できるソフトウェアまたはハードウェア

**手順**:
1.  **既知の位相関係の信号の入力**:
    *   `audio_signal_generator.py` または他のソフトウェアで、以下の信号を生成し、オーディオインターフェースのステレオ入力に送ります。
        *   **モノラル信号**: 左右チャンネルが同一の信号。
        *   **90度位相差の信号**: 左右チャンネル間に90度の位相差がある信号。
        *   **180度位相差の信号**: 左右チャンネル間で位相が反転している信号。
    *   `audio_phase_analyzer.py` を実行し、位相差を測定します。
    *   **検証**:
        *   モノラル信号の場合、位相差が0度に近いことを確認します。
        *   90度位相差の場合、位相差が+90度または-90度に近いことを確認します。
        *   180度位相差の場合、位相差が+180度または-180度に近いことを確認します。
        *   `--plot` オプションを使用した場合、リサジュー図が正しく表示されることを確認します。

### 8. `audio_signal_generator.py`

**目的**: 生成されるWAVファイルの信号特性が正確であることを確認する。

**準備**:
*   信頼できるオーディオ分析ソフトウェア（例: Audacity, REW, スペクトラムアナライザー）

**手順**:
1.  **各種波形の生成と分析**:
    *   サイン波、矩形波、三角波、ノコギリ波を様々な周波数と振幅で生成し、WAVファイルとして保存します。
    *   生成されたWAVファイルをオーディオ分析ソフトウェアで開きます。
    *   **検証**:
        *   波形が期待通りであること（例: サイン波は滑らか、矩形波はシャープなエッジ）。
        *   スペクトラムが期待通りであること（例: サイン波は基本波のみ、矩形波は奇数次高調波）。
        *   振幅が指定したdBFS値に対応していること。
2.  **ノイズの生成と分析**:
    *   ホワイトノイズ、ピンクノイズ、ブラウンノイズ、グレーノイズなどを生成し、WAVファイルとして保存します。
    *   生成されたWAVファイルをオーディオ分析ソフトウェアで開きます。
    *   **検証**:
        *   スペクトラムが各ノイズタイプに期待される周波数特性（例: ピンクノイズはオクターブあたり-3dB）を示していることを確認します。
3.  **スイープ信号の生成と分析**:
    *   線形および対数周波数スイープ、音量スイープを生成し、WAVファイルとして保存します。
    *   生成されたWAVファイルをオーディオ分析ソフトウェアで開きます。
    *   **検証**:
        *   スペクトログラムが期待される周波数または音量の変化を示していることを確認します。
4.  **重み付けの適用**:
    *   ノイズ信号にA, B, C重み付けを適用してWAVファイルを生成します。
    *   生成されたWAVファイルをオーディオ分析ソフトウェアで開きます。
    *   **検証**: スペクトラムが各重み付けカーブの特性を反映していることを確認します。
5.  **フェードイン・フェードアウトの適用**:
    *   フェードイン・アウトを適用した信号を生成し、WAVファイルとして保存します。
    *   生成されたWAVファイルをオーディオ分析ソフトウェアで開きます。
    *   **検証**: 波形が滑らかに立ち上がり、立ち下がっていることを確認します。

### 9. `audio_transient_analyzer.py`

**目的**: インパルス応答およびトーンバースト応答の過渡特性（立ち上がり時間、オーバーシュート、整定時間）が正確に測定されることを確認する。

**準備**:
*   高品質なオーディオインターフェース
*   ループバックケーブル
*   （オプション）既知の過渡応答特性を持つハードウェア（例: 意図的にオーバーシュートを発生させる回路）

**手順**:
1.  **インパルス応答の測定**:
    *   `audio_transient_analyzer.py` を `--signal_type impulse` でループバック接続で実行します。
    *   **検証**:
        *   非常に短い立ち上がり時間（オーディオインターフェースの帯域幅に依存）が測定されることを確認します。
        *   オーバーシュートと整定時間が非常に小さいこと（理想的なループバックの場合）を確認します。
2.  **トーンバースト応答の測定**:
    *   `audio_transient_analyzer.py` を `--signal_type tone_burst` で様々な周波数、サイクル数、エンベロープタイプで実行します。
    *   **検証**:
        *   立ち上がり時間、オーバーシュート、整定時間が、トーンバーストの特性（例: エンベロープタイプ）に応じて変化することを確認します。
        *   意図的にオーバーシュートを発生させるハードウェアを介した場合、オーバーシュートが正しく検出されることを確認します。

### 10. `lufs_meter.py`

**目的**: オーディオファイルのラウドネス（LUFS）およびトゥルーピークがITU-R BS.1770-4 / EBU R128規格に従って正確に測定されることを確認する。

**準備**:
*   ITU-R BS.1770-4 / EBU R128に準拠した既知のラウドネス値を持つテストオーディオファイル（例: EBU Tech 3344のテストファイル）。

**手順**:
1.  **既知のラウドネス値を持つファイルの分析**:
    *   `lufs_meter.py` を、既知のラウドネス値を持つテストオーディオファイルに対して実行します。
    *   **検証**:
        *   統合ラウドネス（Integrated Loudness）、モーメンタリーラウドネス（Momentary Loudness）、ショートタームラウドネス（Short-term Loudness）、ラウドネスレンジ（LRA）、トゥルーピーク（True Peak）が、テストファイルの既知の値と一致することを確認します。
        *   特に、ゲート処理が正しく行われているか（例: 静かな部分がラウドネス計算から除外されているか）を確認します。
2.  **様々な特性を持つファイルの分析**:
    *   ダイナミックレンジの広い音楽、ダイアログのみの音声、非常に圧縮された音声など、様々な特性を持つオーディオファイルを分析します。
    *   **検証**: 各ラウドネス指標が、ファイルの特性を適切に反映していることを確認します。

### 11. `rt60_analyzer.py`

**目的**: 残響時間（RT60）が正確に測定されることを確認する。

**準備**:
*   高品質なオーディオインターフェース
*   測定用マイク
*   インパルス音源（例: 風船の破裂音、スターターピストル、拍手）
*   （オプション）既知の残響時間を持つ空間（例: 無響室、残響室）

**手順**:
1.  **異なる空間での測定**:
    *   残響の少ない空間（例: カーテンや家具の多い部屋）と、残響の多い空間（例: 浴室、空の部屋）でインパルス応答を録音します。
    *   `rt60_analyzer.py` を実行し、RT60を測定します。
    *   **検証**:
        *   残響の少ない空間ではRT60が短く、残響の多い空間ではRT60が長くなることを確認します。
        *   `--plot` オプションを使用した場合、エネルギー減衰曲線が正しく表示され、減衰の傾きがRT60と一致することを確認します。
2.  **既知のRT60を持つ空間での測定（オプション）**:
    *   もし利用可能であれば、既知のRT60を持つ専門的な空間（例: 無響室、残響室）で測定し、ツールの結果が既知の値と一致することを確認します。

### 12. `snr_analyzer.py`

**目的**: 信号対雑音比（SNR）が正確に測定されることを確認する。

**準備**:
*   高品質なオーディオインターフェース
*   ループバックケーブル

**手順**:
1.  **ループバックでのSNR測定**:
    *   `snr_analyzer.py` をループバック接続で実行します。
    *   **検証**:
        *   測定されたSNRが、オーディオインターフェースのSNR仕様に近い値であることを確認します。
        *   非常にクリーンな信号と非常に低いノイズフロアの場合、高いSNR値が測定されることを確認します。
2.  **既知のノイズレベルを加えたSNR測定**:
    *   オーディオインターフェースの入力に、既知のノイズレベルを持つ信号源（例: ノイズジェネレーター）を接続し、SNRを測定します。
    *   **検証**: 測定されたSNRが、信号レベルとノイズレベルの比率から期待される値と一致することを確認します。
3.  **信号レベルとノイズレベルの独立した検証**:
    *   `snr_analyzer.py` が出力する「RMS Signal (Estimated)」と「RMS Noise」の値を、別途オーディオ分析ソフトウェアで測定したRMS値と比較し、一致することを確認します。

### 13. `wow_flutter_analyzer.py`

**目的**: ワウ・フラッターが正確に測定されることを確認する。

**準備**:
*   ワウ・フラッター測定用のテストトーン（例: 3.15kHzまたは3kHzの純粋な正弦波）が録音されたオーディオファイル。
*   （オプション）既知のワウ・フラッター特性を持つアナログ再生機器（例: ターンテーブル、カセットデッキ）。

**手順**:
1.  **既知のワウ・フラッターを持つファイルの分析**:
    *   既知のワウ・フラッター特性を持つテストオーディオファイル（例: ワウ・フラッター測定用レコードやテープ）を再生し、録音します。
    *   `wow_flutter_analyzer.py` を実行し、録音されたファイルを分析します。
    *   **検証**:
        *   測定されたワウ・フラッター値が、テストファイルの既知の値と一致することを確認します。
2.  **安定した信号の分析**:
    *   ワウ・フラッターが非常に少ない（またはゼロに近い）デジタルで生成された純粋なテストトーンを録音し、分析します。
    *   **検証**: 測定されたワウ・フラッター値が非常に低いこと（例: 0.01%以下）を確認します。
3.  **意図的にワウ・フラッターを発生させた信号の分析**:
    *   再生速度を意図的に変動させるなどしてワウ・フラッターを発生させた信号を録音し、分析します。
    *   **検証**: 測定されたワウ・フラッター値が、発生させた変動を反映した値になることを確認します。
    *   `--plot` オプションを使用した場合、周波数偏差のプロットが正しく表示されることを確認します。

## 検証結果の記録

各テストについて、以下の情報を記録します。

*   **テスト日時**:
*   **ツール名とバージョン**:
*   **テスト環境**: OS, Pythonバージョン, オーディオインターフェースのモデル, 接続方法など。
*   **テスト条件**: 使用したオプション、入力信号の特性（周波数、振幅など）。
*   **期待される結果**: 理論値、外部測定器の参照値など。
*   **実際の測定結果**: ツールの出力値。
*   **差異と考察**: 期待値との差異、その原因（判明した場合）、改善点など。
*   **スクリーンショット/プロット**: 視覚的な結果がある場合は添付。

この手順に従うことで、各オーディオ測定ツールの計算の正確性と実機環境での信頼性を体系的に検証できます。

## 仮想ループバックデバイスの導入とテスト方針の変更

新たに仮想ループバックデバイス（ID 15: LoopCombined, ALSA）を導入しました。このデバイスは、Lチャンネルへの入力がLチャンネルへ、Rチャンネルへの入力がRチャンネルへそれぞれループバックされる特性を持っています。

今後は、物理デバイスを用いたテストに加えて、この仮想ループバックデバイスを積極的に活用し、ソフトウェア的なテストを優先して実施します。これにより、物理的な接続や環境に依存しない、より安定したテスト環境を構築し、開発効率の向上を図ります。

## 今後の測定計画

現在の検証は、ツールの基本的な計算精度を確認する最初のステージです。今後は、以下のステージに進むことを計画しています。

### ステージ1: 基本性能評価（現在実施中）
*   **内容**: ループバック接続による各ツールの基本的な精度検証。
*   **目的**: ツールの計算ロジックとアルゴリズムの正当性を、理想的な条件下で確認する。

### ステージ2: 多様なハードウェアでの検証
*   **内容**: 複数の異なるオーディオインターフェース（プロフェッショナル向け、コンシューマー向けなど）を使用して、ステージ1と同様のテストを再度実施する。
*   **目的**: ASIO, Core Audio, ALSAなど、OSやドライバ、ハードウェア実装の違いによる影響を吸収できているかを確認し、ツールの汎用性と安定性を高める。

### ステージ3: 実環境での音響測定
*   **内容**: マイクとスピーカーをシステムに組み込み、実際の部屋の音響特性を測定する。
    *   `rt60_analyzer.py` を用いた、様々な部屋の残響時間の測定。
    *   `audio_freq_response_analyzer.py` を用いた、スピーカーと部屋を組み合わせた状態での周波数応答測定。
*   **目的**: ツールが、電気的なループバックだけでなく、マイクやスピーカーを含む音響測定という、より実用的なシナリオで機能することを確認する。

### ステージ4: アナログ機器の特性測定
*   **内容**: ターンテーブル、カセットデッキ、プリアンプ、エフェクターなどのアナログ機器を測定対象とする。
    *   `wow_flutter_analyzer.py` を用いた、アナログ再生機器の回転ムラの測定。
    *   `audio_analyzer.py` や `audio_imd_analyzer.py` を用いた、アンプやエフェクターの歪率測定。
*   **目的**: アナログ機器特有の微細な変動や歪みを正確に捉え、分析できるかを確認する。

### ステージ5: 自動化とレポート生成
*   **内容**: 一連のテスト（例: THD, 周波数応答, クロストーク）を自動で連続実行し、結果をまとめてHTMLやPDF形式のレポートとして出力する機能の開発。
*   **目的**: 測定プロセスの大幅な効率化と、結果の比較・共有を容易にする。

### audio_analyzer ループバックテストコマンド (ルートディレクトリから実行)

`audio_analyzer` のループバックテストをルートディレクトリから実行するには、以下のコマンドを使用します。

```bash
python audio_analyzer/audio_analyzer.py -ic L -oc L -d 15
```

このコマンドは、`audio_analyzer.py` スクリプトを呼び出し、以下のオプションを指定します。
*   `-ic L`: 入力チャンネルを左 (L) に設定します。
*   `-oc L`: 出力チャンネルを左 (L) に設定します。
*   `-d 15`: 使用するオーディオデバイスのIDを15に設定します。
